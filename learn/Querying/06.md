# Prometheus Cheat Sheet - Basics (Metrics, Labels, Time Series, Scraping)

* https://iximiuz.com/en/posts/prometheus-metrics-labels-time-series/

Here we focus on the most basic Prometheus concepts - metrics, labels, scrapes, and time series.

## What is a metric?

In Prometheus, everything revolves aroundÂ [*metrics*](https://prometheus.io/docs/concepts/data_model/). AÂ *metric*Â is a feature (i.e., a characteristic) of a system that is being measured. Typical examples of metrics are:
åœ¨ Prometheus ä¸­ï¼Œä¸€åˆ‡éƒ½å›´ç»•æŒ‡æ ‡å±•å¼€ã€‚ åº¦é‡æ˜¯è¢«æµ‹é‡ç³»ç»Ÿçš„ä¸€ä¸ªç‰¹å¾ï¼ˆå³ç‰¹å¾ï¼‰ã€‚ æŒ‡æ ‡çš„å…¸å‹ç¤ºä¾‹æœ‰ï¼š

- http_requests_total
- http_request_size_bytes
- system_memory_used_bytes
- node_network_receive_bytes_total

![Prometheus metrics](https://iximiuz.com/prometheus-metrics-labels-time-series/metrics-2000-opt.png "Prometheus metrics")

## What is a label?

The idea of aÂ *metric*Â seems fairly simple. However, there is a problem with such simplicity. On the diagram above, Prometheus monitors several application servers simultaneously. Each of these servers reportsÂ `mem_used_bytes`Â metric. At any given time, how should Prometheus store multiple samples behind a single metric name?
åº¦é‡çš„æƒ³æ³•ä¼¼ä¹ç›¸å½“ç®€å•ã€‚ ç„¶è€Œï¼Œè¿™ç§ç®€å•æ€§å­˜åœ¨ä¸€ä¸ªé—®é¢˜ã€‚ åœ¨ä¸Šå›¾ä¸­ï¼ŒPrometheus åŒæ—¶ç›‘æ§å¤šä¸ªåº”ç”¨ç¨‹åºæœåŠ¡å™¨ã€‚ è¿™äº›æœåŠ¡å™¨ä¸­çš„æ¯ä¸€ä¸ªéƒ½ä¼šæŠ¥å‘Š mem_used_bytes æŒ‡æ ‡ã€‚ åœ¨ä»»ä½•ç»™å®šæ—¶é—´ï¼ŒPrometheus åº”å¦‚ä½•åœ¨å•ä¸ªæŒ‡æ ‡åç§°åé¢å­˜å‚¨å¤šä¸ªæ ·æœ¬ï¼Ÿ

The first option isÂ *aggregation*. Prometheus could sum up all the bytes and store the total memory usage of the whole fleet. Or compute an average memory usage and store it. Or min/max memory usage. Or compute and store all of those together. However, there is always a problem with storing only aggregated metrics - we wouldn't be able to pin down a particular server with a bizarre memory usage pattern based on such data.
ç¬¬ä¸€ä¸ªé€‰é¡¹æ˜¯èšåˆã€‚ Prometheus å¯ä»¥æ±‡æ€»æ‰€æœ‰å­—èŠ‚å¹¶å­˜å‚¨æ•´ä¸ªé˜Ÿåˆ—çš„æ€»å†…å­˜ä½¿ç”¨é‡ã€‚ æˆ–è€…è®¡ç®—å¹³å‡å†…å­˜ä½¿ç”¨é‡å¹¶å­˜å‚¨å®ƒã€‚ æˆ–æœ€å°/æœ€å¤§å†…å­˜ä½¿ç”¨é‡ã€‚ æˆ–è€…è®¡ç®—å¹¶å°†æ‰€æœ‰è¿™äº›å­˜å‚¨åœ¨ä¸€èµ·ã€‚ ç„¶è€Œï¼Œä»…å­˜å‚¨èšåˆæŒ‡æ ‡å§‹ç»ˆå­˜åœ¨ä¸€ä¸ªé—®é¢˜ - æˆ‘ä»¬æ— æ³•æ ¹æ®æ­¤ç±»æ•°æ®ç¡®å®šå…·æœ‰å¥‡æ€ªå†…å­˜ä½¿ç”¨æ¨¡å¼çš„ç‰¹å®šæœåŠ¡å™¨ã€‚

Luckily, Prometheus uses another approach - it can differentiate samples with the same metric name by labeling them. AÂ *label*Â is a certain attribute of a metric. Generally, labels are populated by metric producers (servers in the example above). However, in Prometheus, it's possible to enrich a metric with some static labels based on the producer's identity while recording it on the Prometheus node's side. In the wild, it's common for a Prometheus metric to carry multiple labels.
å¹¸è¿çš„æ˜¯ï¼ŒPrometheus ä½¿ç”¨äº†å¦ä¸€ç§æ–¹æ³• - å®ƒå¯ä»¥é€šè¿‡æ ‡è®°æ¥åŒºåˆ†å…·æœ‰ç›¸åŒåº¦é‡åç§°çš„æ ·æœ¬ã€‚ æ ‡ç­¾æ˜¯åº¦é‡çš„ç‰¹å®šå±æ€§ã€‚ é€šå¸¸ï¼Œæ ‡ç­¾ç”±æŒ‡æ ‡ç”Ÿäº§è€…ï¼ˆä¸Šä¾‹ä¸­çš„æœåŠ¡å™¨ï¼‰å¡«å……ã€‚ ç„¶è€Œï¼Œåœ¨ Prometheus ä¸­ï¼Œå¯ä»¥æ ¹æ®ç”Ÿäº§è€…çš„èº«ä»½ä½¿ç”¨ä¸€äº›é™æ€æ ‡ç­¾æ¥ä¸°å¯ŒæŒ‡æ ‡ï¼ŒåŒæ—¶å°†å…¶è®°å½•åœ¨ Prometheus èŠ‚ç‚¹ä¸€ä¾§ã€‚ åœ¨é‡å¤–ï¼Œæ™®ç½—ç±³ä¿®æ–¯æŒ‡æ ‡å¸¦æœ‰å¤šä¸ªæ ‡ç­¾æ˜¯å¾ˆå¸¸è§çš„ã€‚

Typical examples of labels are:

- instance - anÂ *instance*Â (a server or cronjob process) of aÂ *job*Â being monitored in theÂ `<host>:<port>`Â form
- job - a name of a logical group ofÂ *instances*Â sharing the same purpose
- endpoint - name of an HTTP API endpoint
- method - HTTP method
- status_code - HTTP status code

![Prometheus labels](https://iximiuz.com/prometheus-metrics-labels-time-series/labels-2000-opt.png "Prometheus labels")

## What is scraping?

There are two principally different approaches to collect metrics. A monitoring system can have aÂ *passive*Â orÂ *active*Â collector component. In the case of a passive collector, samples are constantlyÂ *pushed*Â by active instances to the collector. In contrast, an active collector periodicallyÂ *pulls*Â samples from instances that passively expose them.
æœ‰ä¸¤ç§ä¸»è¦ä¸åŒçš„æ–¹æ³•æ¥æ”¶é›†æŒ‡æ ‡ã€‚ ç›‘æ§ç³»ç»Ÿå¯ä»¥å…·æœ‰æ— æºæˆ–æœ‰æºæ”¶é›†å™¨ç»„ä»¶ã€‚ å¯¹äºè¢«åŠ¨æ”¶é›†å™¨ï¼Œæ ·æœ¬ä¸æ–­åœ°ç”±ä¸»åŠ¨å®ä¾‹æ¨é€åˆ°æ”¶é›†å™¨ã€‚ ç›¸åï¼Œä¸»åŠ¨æ”¶é›†å™¨ä¼šå®šæœŸä»è¢«åŠ¨å…¬å¼€æ ·æœ¬çš„å®ä¾‹ä¸­æå–æ ·æœ¬ã€‚

Prometheus uses aÂ *pull model*, and the metric collection process is calledÂ *scraping*.
Prometheus é‡‡ç”¨æ‹‰æ¨¡å‹ï¼ŒæŒ‡æ ‡æ”¶é›†è¿‡ç¨‹ç§°ä¸ºæŠ“å–ã€‚

In a system with aÂ *passive collector*, there is no need to register monitored instances upfront. Instead, you need to communicate the address of the collector endpoint to the instances, so they could start pushing data. However, in the case of anÂ *active collector*, one should supply the list of instances to be scraped beforehand. Or teach the monitoring system how to build such a list dynamically using one of the supported service discovery mechanisms.
åœ¨å…·æœ‰è¢«åŠ¨æ”¶é›†å™¨çš„ç³»ç»Ÿä¸­ï¼Œæ— éœ€é¢„å…ˆæ³¨å†Œå—ç›‘æ§çš„å®ä¾‹ã€‚ ç›¸åï¼Œæ‚¨éœ€è¦å°†æ”¶é›†å™¨ç«¯ç‚¹çš„åœ°å€ä¼ è¾¾ç»™å®ä¾‹ï¼Œä»¥ä¾¿å®ƒä»¬å¯ä»¥å¼€å§‹æ¨é€æ•°æ®ã€‚ ä½†æ˜¯ï¼Œå¦‚æœæ˜¯æ´»åŠ¨æ”¶é›†å™¨ï¼Œåˆ™åº”é¢„å…ˆæä¾›è¦æŠ“å–çš„å®ä¾‹åˆ—è¡¨ã€‚ æˆ–è€…æ•™å¯¼ç›‘æ§ç³»ç»Ÿå¦‚ä½•ä½¿ç”¨æ”¯æŒçš„æœåŠ¡å‘ç°æœºåˆ¶ä¹‹ä¸€åŠ¨æ€æ„å»ºè¿™æ ·çš„åˆ—è¡¨ã€‚

In Prometheus, scraping is configured via providing a static list ofÂ `<host>:<port>`Â **scraping targets**. It's also possible to configure a service-discovery-specific (consul, docker, kubernetes, ec2, etc.) endpoint to fetch such a list at runtime. You also need to specify aÂ **scrape interval**Â - a delay between any two consecutive scrapes. Surprisingly or not, it's common for such an interval to be several seconds or even tens of seconds long.
åœ¨ Prometheus ä¸­ï¼Œé€šè¿‡æä¾› `<host>:<port>` æŠ“å–ç›®æ ‡çš„é™æ€åˆ—è¡¨æ¥é…ç½®æŠ“å–ã€‚ è¿˜å¯ä»¥é…ç½®ç‰¹å®šäºæœåŠ¡å‘ç°çš„ï¼ˆconsulã€dockerã€kubernetesã€ec2 ç­‰ï¼‰ç«¯ç‚¹ä»¥åœ¨è¿è¡Œæ—¶è·å–æ­¤ç±»åˆ—è¡¨ã€‚ æ‚¨è¿˜éœ€è¦æŒ‡å®šæŠ“å–é—´éš” - ä»»æ„ä¸¤æ¬¡è¿ç»­æŠ“å–ä¹‹é—´çš„å»¶è¿Ÿã€‚ ä¸ç®¡æ˜¯å¦ä»¤äººæƒŠè®¶ï¼Œè¿™æ ·çš„é—´éš”é€šå¸¸é•¿è¾¾å‡ ç§’ç”šè‡³å‡ åç§’ã€‚

For a monitoring system, the design choice to use a pull model and relatively long scrape intervals have some interesting repercussions...
å¯¹äºç›‘æ§ç³»ç»Ÿï¼Œé€‰æ‹©ä½¿ç”¨æ‹‰æ¨¡å‹å’Œç›¸å¯¹è¾ƒé•¿çš„æŠ“å–é—´éš”ä¼šäº§ç”Ÿä¸€äº›æœ‰è¶£çš„å½±å“...

## What is a time series in Prometheus?

**Side note 1:**Â Despite being born in the age of distributed systems, every Prometheus server node is autonomous. I.e., there is no distributed metric storage in the default Prometheus setup, and every node acts as a self-sufficient monitoring server with local metric storage. It simplifies a lot of things, including the following explanation, because we don't need to think of how to merge overlapping series from different Prometheus nodes*Â ğŸ˜‰
æ—æ³¨ 1ï¼šå°½ç®¡è¯ç”Ÿäºåˆ†å¸ƒå¼ç³»ç»Ÿæ—¶ä»£ï¼Œä½†æ¯ä¸ª Prometheus æœåŠ¡å™¨èŠ‚ç‚¹éƒ½æ˜¯è‡ªæ²»çš„ã€‚ å³ï¼Œé»˜è®¤çš„ Prometheus è®¾ç½®ä¸­æ²¡æœ‰åˆ†å¸ƒå¼æŒ‡æ ‡å­˜å‚¨ï¼Œæ¯ä¸ªèŠ‚ç‚¹éƒ½å……å½“å…·æœ‰æœ¬åœ°æŒ‡æ ‡å­˜å‚¨çš„è‡ªç»™è‡ªè¶³çš„ç›‘æ§æœåŠ¡å™¨ã€‚ å®ƒç®€åŒ–äº†å¾ˆå¤šäº‹æƒ…ï¼ŒåŒ…æ‹¬ä¸‹é¢çš„è§£é‡Šï¼Œå› ä¸ºæˆ‘ä»¬ä¸éœ€è¦è€ƒè™‘å¦‚ä½•åˆå¹¶æ¥è‡ªä¸åŒ Prometheus èŠ‚ç‚¹çš„é‡å ç³»åˆ—

![Prometheus series](https://iximiuz.com/prometheus-metrics-labels-time-series/time-series-2000-opt.png "Prometheus time series")

In general, a stream of timestamped values is called aÂ **time series**. In the above example, there are four different time series. But only two metric names. I.e., a time series in Prometheus is defined by a combination of a metric name and a particular set of key-value labels.
ä¸€èˆ¬æ¥è¯´ï¼Œå¸¦æœ‰æ—¶é—´æˆ³çš„å€¼æµç§°ä¸ºæ—¶é—´åºåˆ—ã€‚ åœ¨ä¸Šé¢çš„ç¤ºä¾‹ä¸­ï¼Œæœ‰å››ä¸ªä¸åŒçš„æ—¶é—´åºåˆ—ã€‚ ä½†åªæœ‰ä¸¤ä¸ªæŒ‡æ ‡åç§°ã€‚ å³ï¼ŒPrometheus ä¸­çš„æ—¶é—´åºåˆ—æ˜¯ç”±æŒ‡æ ‡åç§°å’Œä¸€ç»„ç‰¹å®šçš„é”®å€¼æ ‡ç­¾çš„ç»„åˆå®šä¹‰çš„ã€‚

**Side note 2:**Â Values are always floating-point numbers; timestamps are integers storing the number of milliseconds since the Unix epoch.
æ—æ³¨ 2ï¼šå€¼å§‹ç»ˆæ˜¯æµ®ç‚¹æ•°ï¼› æ—¶é—´æˆ³æ˜¯å­˜å‚¨è‡ª Unix çºªå…ƒä»¥æ¥çš„æ¯«ç§’æ•°çš„æ•´æ•°ã€‚

Every such time series is stored separately on the Prometheus node in the form of an append-only file. Since a series is defined by the label value(s), one needs to be careful with labels that might have high cardinality.
æ¯ä¸ªè¿™æ ·çš„æ—¶é—´åºåˆ—éƒ½ä»¥ä»…é™„åŠ æ–‡ä»¶çš„å½¢å¼å•ç‹¬å­˜å‚¨åœ¨ Prometheus èŠ‚ç‚¹ä¸Šã€‚ ç”±äºç³»åˆ—æ˜¯ç”±æ ‡ç­¾å€¼å®šä¹‰çš„ï¼Œå› æ­¤éœ€è¦å°å¿ƒå¯èƒ½å…·æœ‰é«˜åŸºæ•°çš„æ ‡ç­¾ã€‚

The termsÂ *time series*,Â *series*, andÂ *metric*Â are often used interchangeably. However, in Prometheus, a metric technically means a group of [time] series.
æœ¯è¯­â€œæ—¶é—´åºåˆ—â€ã€â€œåºåˆ—â€å’Œâ€œåº¦é‡â€é€šå¸¸å¯ä»¥äº’æ¢ä½¿ç”¨ã€‚ ç„¶è€Œï¼Œåœ¨ Prometheus ä¸­ï¼Œåº¦é‡åœ¨æŠ€æœ¯ä¸Šæ„å‘³ç€ä¸€ç»„[æ—¶é—´]åºåˆ—ã€‚

## Downsides of active scraping

Since it's a single node scraping multiple distributed endpoints with potentially different performance and network conditions, the exact sample timestamps will (although most of the time just slightly) vary for every scrape. Because of that and of the potential loss of some scrapes, the interval between two samples in a given time series is neither constant nor multiplication of the scrape interval. Remember the repercussions I mentioned above?
ç”±äºå®ƒæ˜¯å•ä¸ªèŠ‚ç‚¹æŠ“å–å…·æœ‰å¯èƒ½ä¸åŒçš„æ€§èƒ½å’Œç½‘ç»œæ¡ä»¶çš„å¤šä¸ªåˆ†å¸ƒå¼ç«¯ç‚¹ï¼Œå› æ­¤æ¯æ¬¡æŠ“å–çš„ç¡®åˆ‡æ ·æœ¬æ—¶é—´æˆ³å°†ä¼šï¼ˆå°½ç®¡å¤§å¤šæ•°æ—¶å€™åªæ˜¯ç•¥æœ‰ä¸åŒï¼‰ã€‚ ç”±äºè¿™ä¸€ç‚¹ä»¥åŠæŸäº›åˆ®æ“¦çš„æ½œåœ¨æŸå¤±ï¼Œç»™å®šæ—¶é—´åºåˆ—ä¸­ä¸¤ä¸ªæ ·æœ¬ä¹‹é—´çš„é—´éš”æ—¢ä¸æ˜¯å¸¸æ•°ï¼Œä¹Ÿä¸æ˜¯åˆ®æ“¦é—´éš”çš„ä¹˜ç§¯ã€‚ è¿˜è®°å¾—æˆ‘ä¸Šé¢æåˆ°çš„åæœå—ï¼Ÿ

![Missing scrapes illustration](https://iximiuz.com/prometheus-metrics-labels-time-series/scrape-interval-drift-2000-opt.png)

Prometheus node scraping two services every 10 seconds - actual samples aren't ideally aligned in time.
Prometheus èŠ‚ç‚¹æ¯ 10 ç§’æŠ“å–ä¸¤ä¸ªæœåŠ¡ - å®é™…æ ·æœ¬åœ¨æ—¶é—´ä¸Šå¹¶ä¸ç†æƒ³ã€‚

There is another interesting, more important pitfall to be aware of. If a target reports aÂ *gauge*Â (i.e.,Â **instant measurement**) metric that changes more frequently than it's scraped, the intermediate values will never be seen by the Prometheus node. Thus, it may causeÂ *blindness*Â of the monitoring system to some bizarre patterns:
è¿˜æœ‰å¦ä¸€ä¸ªæœ‰è¶£çš„ã€æ›´é‡è¦çš„é™·é˜±éœ€è¦æ³¨æ„ã€‚ å¦‚æœç›®æ ‡æŠ¥å‘Šçš„é‡è§„ï¼ˆå³å³æ—¶æµ‹é‡ï¼‰æŒ‡æ ‡çš„å˜åŒ–é¢‘ç‡é«˜äºå…¶æŠ“å–é¢‘ç‡ï¼Œåˆ™ Prometheus èŠ‚ç‚¹å°†æ°¸è¿œçœ‹ä¸åˆ°ä¸­é—´å€¼ã€‚ å› æ­¤ï¼Œå®ƒå¯èƒ½ä¼šå¯¼è‡´ç›‘æ§ç³»ç»Ÿå¯¹ä¸€äº›å¥‡æ€ªçš„æ¨¡å¼è§†è€Œä¸è§ï¼š

Obviously,Â **counter**Â (i.e., monotonically incrementing measurement) metrics don't have such a problem.
æ˜¾ç„¶ï¼Œè®¡æ•°å™¨ï¼ˆå³å•è°ƒé€’å¢æµ‹é‡ï¼‰æŒ‡æ ‡ä¸å­˜åœ¨è¿™æ ·çš„é—®é¢˜ã€‚

